
function pupl_UI
% The UI layout is stored in this file

global pupl_globals

pupl_globals.UI = figure('Name', 'PuPl',...
    'NumberTitle', 'off',...
    'UserData', struct(...
        'dataCount', 0,...
        'activeEyeDataIdx', logical([])),...
    'CloseRequestFcn', @savewarning,...
    'MenuBar', 'none',...
    'ToolBar', 'none',...
    'Visible', 'off');
userInterface = pupl_globals.UI;
set(userInterface, 'SizeChangedFcn', @preservelayout);

%% Active recordings

sbw = 0.03; % scrollbar width
oripos = [0 0 1 1];
h = uibuttongroup(userInterface,...
    'Title', 'Active recordings',...
    'FontSize', 10,...
    'Tag', 'activeEyeDataPanel',...
    'Units', 'normalized',...
    'Position', oripos,...
    'UserData', struct(...
        'OriginalPos', oripos));
UI_adjust(h);
uicontrol('Style','Slider','Parent',1,...
    'Tag', 'dataScroller',...
    'Units', 'normalized',...
    'Position', [1 - sbw 0 sbw 1],...
    'Value', 1,...
    'Callback', @(h, e) scrolldatapanel(h, e));
set(userInterface, 'WindowScrollWheelFcn', @(h, e) scrolldatapanel(h, e));

%% File menu

fileMenu = uimenu(userInterface,...
    'Tag', 'fileMenu',...
    'Label', '&File');
uimenu(fileMenu,...
    'Label', ['&Load binary ' sprintf('(.%s)', pupl_globals.ext)],...
    'Callback', @(h, e)...
        appendtodata(@() pupl_import('native', true), 'load data'));
uimenu(fileMenu,...
    'Tag', 'pupl:import-eye',...
    'Label', '&Import');
saveMenu = uimenu(fileMenu,...
    'Label', 'Save &as',...
    'UserData', struct('CheckEnableFunction', @() isnonemptyfield(getactivedata), 'msg', 'This option requires at least one recording to be currently active'));
uimenu(saveMenu,...
    'Label', ['&Binary ' sprintf('(.%s)', pupl_globals.ext)],...
    'Callback', @(src, event)...
        pupl_save(getactivedata, 'as', 'bin', 'data', 'eye'));
uimenu(saveMenu,...
    'Label', '&Text (.txt for data, .csv for events)',...
    'Callback', @(src, event)...
        pupl_save(getactivedata, 'as', 'txt'));
batchSaveMenu = uimenu(fileMenu,...
    'Label', '&Batch save',...
    'UserData', struct('CheckEnableFunction', @() isnonemptyfield(getactivedata), 'msg', 'This option requires at least one recording to be currently active'));
uimenu(batchSaveMenu,...
    'Label', ['&Binary ' sprintf('(.%s)', pupl_globals.ext)],...
    'Callback', @(src, event)...
        pupl_save(getactivedata, 'as', 'bin', 'method', 'batch', 'data', 'eye'));
uimenu(batchSaveMenu,...
    'Label', '&Text (.txt for data, .csv for events)',...
    'Callback', @(src, event)...
        pupl_save(getactivedata, 'as', 'txt', 'method', 'batch'));
%% BIDS sub-menu
bidsmenu = uimenu(fileMenu,...
    'Label', 'BI&DS');
uimenu(bidsmenu,...
    'Label', ['&Load binary ' sprintf('(.%s)', pupl_globals.ext)],...
    'Callback', @(src, event)...
        appendtodata(@() pupl_import(...
            'native', true,...
            'bids', true),...
            'load data'));
uimenu(bidsmenu,...
    'Tag', 'pupl:bids-import-eye',...
    'Label', '&Import');
bidsSaveMenu = uimenu(bidsmenu,...
    'Label', '&Save as',...
    'UserData', struct('CheckEnableFunction', @() isnonemptyfield(getactivedata), 'msg', 'This option requires at least one recording to be currently active'));
uimenu(bidsSaveMenu,...
    'Label', ['&Binary ' sprintf('(.%s)', pupl_globals.ext)],...
    'Callback', @(src, event)...
        pupl_save(getactivedata, 'as', 'bin', 'method', 'bids'));
uimenu(bidsSaveMenu,...
    'Label', '&Text (.txt for data, .csv for events)',...
    'Callback', @(src, event)...
        pupl_save(getactivedata, 'as', 'txt', 'method', 'bids'));

%% Edit menu

editMenu = uimenu(userInterface,...
    'Label', '&Edit',...
    'UserData', struct(...
        'CheckEnableFunction', @()(timeline_allowed('any') || (numel(evalin('base', pupl_globals.datavarname)) > 0)),...
        'msg', 'This menu requires at least one recording to be currently active, and for some processing history to exist.'));
uimenu(editMenu,...
    'Label', '&Undo',...
    'Tag', 'undo',...
    'UserData', struct('CheckEnableFunction', @()timeline_allowed('b'), 'msg', 'No action to undo'),...
    'Callback', @(src, event)...
        updateglobals('w', @() pupl_timeline('b'), 1, false));
uimenu(editMenu,...
    'Label', '&Redo',...
    'Tag', 'redo',...
    'UserData', struct('CheckEnableFunction', @()timeline_allowed('f'), 'msg', 'No action to redo'),...
    'Callback', @(src, event)...
        updateglobals('w', @() pupl_timeline('f'), 1, false));
uimenu(editMenu,...
    'Label', '(De)select &all data',...
    'Separator', 'on',...
    'UserData', struct('CheckEnableFunction', @()(numel(evalin('base', pupl_globals.datavarname)) > 0), 'msg', 'No data to deselect'),...
    'Tag', 'selectAllData',...
    'Callback', @(src, event) selectalldata);
uimenu(editMenu,...
    'Label', '&Duplicate active recordings',...
    'UserData', struct('CheckEnableFunction', @()(numel(evalin('base', pupl_globals.datavarname)) > 0), 'msg', 'No active recordings'),...
    'Callback', @(h, e)...
        appendtodata(@() pupl_copy(getactivedata), 'duplicate data'));
uimenu(editMenu,...
    'Label', '&Remove recordings',...
    'UserData', struct('CheckEnableFunction', @()numel(evalin('base', pupl_globals.datavarname)) > 0, 'msg', 'No recordings to remove'),...
    'Callback', @(src, event) deletedata);

%% Tools menu

toolsMenu = uimenu(userInterface,...
    'Label', '&Tools',...
    'UserData', struct('CheckEnableFunction', @() isnonemptyfield(getactivedata), 'msg', 'This option requires at least one recording to be currently active'));
uimenu(toolsMenu,...
    'Label', 'Save &processing history to script',...
    'Callback', @(src, event) pupl_history('wt'));
uimenu(toolsMenu,...
    'Label', '&Run processing script',...
    'Callback', @(src, event)...
        updateactivedata(@() pupl_pipeline(getactivedata)));
uimenu(toolsMenu,...
    'Label', 'R&eload raw data',...
    'Callback', @(src, event)...
        updateactivedata(@() pupl_reload(getactivedata)));

%% Prep menu

prepMenu = uimenu(userInterface,...
    'Label', '&Prep',...
    'UserData', struct('CheckEnableFunction', @() isnonemptyfield(getactivedata), 'msg', 'This option requires at least one recording to be currently active'));
uimenu(prepMenu,...
    'Label', 'Make recordings &monocular',...
    'UserData', struct('CheckEnableFunction', @() isnonemptyfield(getactivedata), 'msg', 'This option requires at least one recording to be currently active'),...
    'Callback', @(src, event) pupl_UI_procwrap(@pupl_eye));
uimenu(prepMenu,...
    'Label', '&Concatenate recordings',...
    'UserData', struct('CheckEnableFunction', @() isnonemptyfield(getactivedata), 'msg', 'This option requires at least one recording to be currently active'),...
    'Callback', @(src, event) pupl_UI_procwrap({@pupl_cat}));
uimenu(prepMenu,...
    'Label', '&Crop recordings',...
    'UserData', struct('CheckEnableFunction', @() isnonemptyfield(getactivedata), 'msg', 'This option requires at least one recording to be currently active'),...
    'Callback', @(src, event) pupl_UI_procwrap(@pupl_crop));

%% Preprocessing menu

processingMenu = uimenu(userInterface,...
    'Label', 'P&reprocess',...
    'Tag', 'Preprocess',...
    'UserData', struct('CheckEnableFunction', @() isnonemptyfield(getactivedata), 'msg', 'This option requires at least one recording to be currently active'));
excludeRecsMenu = uimenu(processingMenu,...
    'Label', 'E&xclude recordings');
uimenu(excludeRecsMenu,...
    'Label', '&Manually',...
    'Callback', @(src, event) pupl_UI_procwrap({@pupl_rm}, 'method', 'manual'));
uimenu(excludeRecsMenu,...
    'Label', 'By &standard deviation of pupil size',...
    'Callback', @(src, event) pupl_UI_procwrap({@pupl_rm}, 'method', 'std'));
uimenu(excludeRecsMenu,...
    'Label', 'By missing &data',...
    'Callback', @(src, event) pupl_UI_procwrap({@pupl_rm}, 'method', 'missing'));
uimenu(excludeRecsMenu,...
    'Label', 'By &correlation between left and right pupil size',...
    'UserData', struct(...
        'CheckEnableFunction', @()(isnonemptyfield(getactivedata, 'pupil', 'right') && isnonemptyfield(getactivedata, 'pupil', 'left')),...
        'msg', 'Binocular data required'),...
    'Callback', @(src, event) pupl_UI_procwrap({@pupl_rm}, 'method', 'corr'));
uimenu(excludeRecsMenu,...
    'Label', 'By percent rejected &epochs',...
    'UserData', struct('CheckEnableFunction', @()(isnonemptyfield(mergefields(getactivedata, 'epoch'))), 'msg', 'This option becomes available when epochs are defined'),...
    'Callback', @(src, event) pupl_UI_procwrap({@pupl_rm}, 'method', 'pct epochs'));
uimenu(excludeRecsMenu,...
    'Label', 'By &number of rejected epochs',...
    'UserData', struct('CheckEnableFunction', @()(isnonemptyfield(mergefields(getactivedata, 'epoch'))), 'msg', 'This option becomes available when epochs are defined'),...
    'Callback', @(src, event) pupl_UI_procwrap({@pupl_rm}, 'method', 'n epochs'));
uimenu(processingMenu,...
    'Label', '&Downsample',...
    'Callback', @(src, event)...
        pupl_UI_procwrap(@pupl_downsample));
areaDiamConversionMenu = uimenu(processingMenu,...
    'Label', 'Con&vert pupil size');
uimenu(areaDiamConversionMenu,...
    'Label', '&Area to diameter',...
    'Callback', @(src, event)...
        pupl_UI_procwrap(@pupl_ad_convert, 'to', 'diameter'));
uimenu(areaDiamConversionMenu,...
    'Label', '&Diameter to area',...
    'Callback', @(src, event)...
        pupl_UI_procwrap(@pupl_ad_convert, 'to', 'area'));
uimenu(processingMenu,...
    'Label', '&Z-score pupil size data',...
    'Callback', @(src, event)...
        pupl_UI_procwrap(@pupl_zscore));
trimmingMenu = uimenu(processingMenu,...
    'Label', '&Trim data');
uimenu(trimmingMenu,...
    'Label', 'Trim extreme &pupil size measurements',...
    'Callback', @(src, event)...
        pupl_UI_procwrap(@pupl_trim_pupil));
uimenu(trimmingMenu,...
    'Label', 'Trim extreme &gaze measurements',...
    'Callback', @(src, event)...
        pupl_UI_procwrap(@pupl_trim_gaze));
uimenu(trimmingMenu,...
    'Label', 'Trim by extreme &dilation speed (Kret & Sjak-Shie, 2019)',...
    'Callback', @(src, event)...
        pupl_UI_procwrap(@pupl_trim_dilationspeed));
uimenu(trimmingMenu,...
    'Label', 'Trim &isolated samples (Kret & Sjak-Shie, 2019)',...
    'Callback', @(src, event)...
        pupl_UI_procwrap(@pupl_trim_short));
blinksMenu = uimenu(processingMenu,...
    'Label', '&Blinks');
uimenu(blinksMenu,...
    'Label', 'Identify blinks using pupillometry &noise (Hershman, Henik, & Cohen, 2018)',...
    'Callback', @(src, event)...
        pupl_UI_procwrap(@pupl_blink_id, 'method', 'noise'));
uimenu(blinksMenu,...
    'Label', ['Identify blinks by &velocity profile (Math' char(244) 't, 2013)'],...
    'Callback', @(src, event)...
        pupl_UI_procwrap(@pupl_blink_id, 'method', 'velocity'));
uimenu(blinksMenu,...
    'Label', 'Identify blinks by consecutive &missing data',...
    'Callback', @(src, event)...
        pupl_UI_procwrap(@pupl_blink_id, 'method', 'missing'));
uimenu(blinksMenu,...
    'Separator', 'on',...
    'Label', '&Remove blink samples',...
    'Callback', @(src, event)...
        pupl_UI_procwrap(@pupl_blink_rm));
filterMenu = uimenu(processingMenu,...
    'Label', '&Filter');
pupilFiltMenu = uimenu(filterMenu,...
    'Label', 'Pupil &size');
uimenu(pupilFiltMenu,...
    'Label', 'Moving &median',...
    'Callback', @(src, event)...
        pupl_UI_procwrap(@pupl_filt, 'data', 'pupil', 'avfunc', 'median'));
uimenu(pupilFiltMenu,...
    'Label', '&Windowed moving mean',...
    'Callback', @(src, event)...
        pupl_UI_procwrap(@pupl_filt, 'data', 'pupil', 'avfunc', 'mean'));
gazeFiltMenu = uimenu(filterMenu,...
    'Label', '&Gaze');
uimenu(gazeFiltMenu,...
    'Label', 'Moving &median',...
    'Callback', @(src, event)...
        pupl_UI_procwrap(@pupl_filt, 'data', 'gaze', 'avfunc', 'median'));
saccadesMenu = uimenu(processingMenu,...
    'Label', '&Saccades (Salvucci & Goldberg, 2000)');
uimenu(saccadesMenu,...
    'Label', '&Identify saccades and fixations',...
    'Callback', @(src, event)...
        pupl_UI_procwrap(@pupl_saccades));
uimenu(saccadesMenu,...
    'Label', 'Map gaze data to fixation &centroids',...
    'Callback', @(src, event)...
        pupl_UI_procwrap(@pupl_map2fix))

%% PFE sub-menu

PFEmenu = uimenu(processingMenu,...
    'Label', 'Pupil foreshortening &error correction');
uimenu(PFEmenu,...
    'Label', 'Multivariate &linear detrend (Brisson et al., 2013)',...
    'Callback', @(src, event)...
        pupl_UI_procwrap(@pupl_PFE_lm));
%{
uimenu(PFEmenu,...
    'Label', 'Piecewise &quartic detrend in gaze x (Gagl, Hawelka, & Hutzler, 2011)',...
    'Callback', @(src, event)...
        pupl_UI_procwrap(@pupl_PFE_quart));
%}
uimenu(PFEmenu,...
    'Separator', 'on',...
    'Label', 'Convert ga&ze units from pixels to millimeters/re-reference gaze coordinates',...
    'Callback', @(src, event)...
        pupl_UI_procwrap(@pupl_px2mm));
uimenu(PFEmenu,...
    'Label', 'Add coordinates of experimental setup',...
    'Callback', @(src, event)...
        pupl_UI_procwrap(@pupl_PFE_coords));
uimenu(PFEmenu,...
    'Label', '&Geometric PFE correction (Hayes & Petrov, 2016)',...
    'UserData', struct('CheckEnableFunction', @() ...
            isnonemptyfield(getactivedata, 'coords', 'left') &...
            isnonemptyfield(getactivedata, 'coords', 'right') &...
            isnonemptyfield(getactivedata, 'coords', 'camera') &...
            isnonemptyfield(getactivedata, 'gaze'),...
        'msg', 'Coordinates of experimental setup must be added'),...
    'Callback', @(src, event)...
        pupl_UI_procwrap(@pupl_PFE_correct));

%% Rest of preprocessing menu

interpMenu = uimenu(processingMenu,...
    'Label', '&Interpolate missing data');
uimenu(interpMenu,...
    'Label', 'Pupil &size',...
    'Callback', @(src, event)...
        pupl_UI_procwrap(@pupl_interp, 'data', 'pupil'));
uimenu(interpMenu,...
    'Label', '&Gaze',...
    'Callback', @(src, event)...
        pupl_UI_procwrap(@pupl_interp, 'data', 'gaze'));

%% Trials menu

trialsMenu = uimenu(userInterface,...
    'Label', 'Tr&ials',...
    'UserData', struct('CheckEnableFunction', @() isnonemptyfield(getactivedata), 'msg', 'This option requires at least one recording to be currently active'));
uimenu(trialsMenu,...
    'Label', '&View events',...
    'Callback', @(src, event)...
        plotforeach(getactivedata, 'Events', @pupl_event_view));
uimenu(trialsMenu,...
    'Label', '&Delete events',...
    'Callback', @(src, event)...
        pupl_UI_procwrap(@pupl_event_rm));

%% Event logs menu

eventLogsMenu = uimenu(trialsMenu,...
    'Label', '&Event logs',...
    'Separator', 'on');
uimenu(eventLogsMenu,...
    'Tag', 'pupl:import-event',...
    'Label', '&Import');
uimenu(eventLogsMenu,...
    'Tag', 'pupl:bids-import-event',...
    'Label', 'Import from &BIDS');
syncmenu = uimenu(eventLogsMenu,...
    'Label', '&Synchronize with eye data',...
    'UserData', struct('CheckEnableFunction', @()isnonemptyfield(getactivedata, 'eventlog'), 'msg', 'No event log found'));
uimenu(syncmenu,...
    'Label', 'By &timestamps',...
    'Callback', @(src, event)...
        pupl_UI_procwrap(@pupl_alignbytimestamp));
uimenu(syncmenu,...
    'Label', 'By shared &events (e.g. sync triggers)',...
    'Callback', @(src, event)...
        pupl_UI_procwrap(@pupl_alignbysync));
exportEventLogsMenu = uimenu(eventLogsMenu,...
    'Separator', 'on',...
    'Label', '&Export');
uimenu(exportEventLogsMenu,...
    'Label', '&CSV',...
    'Callback', @(src, event)...
        pupl_save(getactivedata, 'as', 'txt', 'data', 'event'));
uimenu(exportEventLogsMenu,...
    'Label', 'BIDS-compliant &TSV',...
    'Callback', @(src, event)...
        pupl_save(getactivedata, 'as', 'bin', 'data', 'event'));
batchExportEventLogsMenu = uimenu(eventLogsMenu,...
    'Label', '&Batch export');
uimenu(batchExportEventLogsMenu,...
    'Label', '&CSV',...
    'Callback', @(src, event)...
        pupl_save(getactivedata, 'as', 'txt', 'method', 'batch', 'data', 'event'));
uimenu(batchExportEventLogsMenu,...
    'Label', 'BIDS-compliant &TSV',...
    'Callback', @(src, event)...
        pupl_save(getactivedata, 'as', 'bin', 'method', 'batch', 'data', 'event'));

%% Event variables

evarMenu = uimenu(trialsMenu,...
    'Label', 'Event &variables',...
    'UserData', struct('CheckEnableFunction', @() isnonemptyfield(getactivedata, 'event'), 'msg', 'No event data found'));
uimenu(evarMenu,...
    'Label', 'Compute &reaction times',...
    'Callback', @(src, event)...
        pupl_UI_procwrap(@pupl_getrt));
uimenu(evarMenu,...
    'Label', 'Read event variables from event &names',...
    'Callback', @(src, event)...
        pupl_UI_procwrap(@pupl_evar_add, 'method', 're'));
uimenu(evarMenu,...
    'Label', '&Compute event variables',...
    'Callback', @(src, event)...
        pupl_UI_procwrap(@pupl_evar_add, 'method', 'evar'));
uimenu(evarMenu,...
    'Label', 'Make &string event variables numeric',...
    'UserData', struct('CheckEnableFunction', @() (~isempty(pupl_evar_getnames(mergefields(getactivedata, 'event')))), 'msg', 'No event variables found'),...
    'Callback', @(src, event)...
        pupl_UI_procwrap(@pupl_evar_map));
uimenu(evarMenu,...
    'Label', '&Homogenize event variables within trials',...
    'Callback', @(src, event)...
        pupl_UI_procwrap(@pupl_evar_hg));
uimenu(evarMenu,...
    'Separator', 'on',...
    'Label', '&Delete event variables',...
    'Callback', @(src, event)...
        pupl_UI_procwrap(@pupl_evar_del));
uimenu(evarMenu,...
    'Label', '&Filter test',...
    'Callback', @(src, event)...
        pupl_UI_event_select(getactivedata, 'prompt', 'Select events'));

%% Misc trial stuff

uimenu(trialsMenu,...
    'Label', 'Find &compound events',...
    'UserData', struct('CheckEnableFunction', @() isnonemptyfield(getactivedata, 'event'), 'msg', 'No event data found'),...
    'Callback', @(src, event)...
        pupl_UI_procwrap(@pupl_higherorderevents));
uimenu(trialsMenu,...
    'Label', '&Define epochs',...
    'UserData', struct('CheckEnableFunction', @() isnonemptyfield(getactivedata, 'event'), 'msg', 'No event data found'),...
    'Separator', 'on',...
    'Callback', @(src, event)...
        pupl_UI_procwrap(@pupl_epoch));
baselineMenu = uimenu(trialsMenu,...
    'Label', '&Baseline correction and normalization (Winn, Wendt, Koelewijn, & Kuchinsky, 2018)',...
    'UserData', struct('CheckEnableFunction', @() isnonemptyfield(getactivedata, 'epoch'), 'msg', 'This option becomes available when epochs are defined'));
uimenu(baselineMenu,...
    'Label', '&Baseline correction',...
    'Callback', @(src, event)...
        pupl_UI_procwrap(@pupl_baseline));
uimenu(baselineMenu,...
    'Label', 'Undo &baseline correction',...
    'UserData', struct('CheckEnableFunction', @() isnonemptyfield(getactivedata, 'epoch', 'baseline'), 'msg', 'Baseline correction must be performed first'),...
    'Callback', @(src, event)...
        pupl_UI_procwrap(@pupl_baseline_rm));
uimenu(baselineMenu,...
    'Separator', 'on',...
    'Label', '&Normalization',...
    'UserData', struct('CheckEnableFunction', @() isnonemptyfield(getactivedata, 'epoch', 'baseline'), 'msg', 'Baseline correction must be performed first'),...
    'Callback', @(src, event)...
        pupl_UI_procwrap(@pupl_normalize));
uimenu(baselineMenu,...
    'Label', 'Undo &normalization',...
    'UserData', struct('CheckEnableFunction', @() isnonemptyfield(getactivedata, 'epoch', 'baseline'), 'msg', 'Baseline correction must be performed first'),...
    'Callback', @(src, event)...
        pupl_UI_procwrap(@pupl_normalize_rm));
trialRejectionMenu = uimenu(trialsMenu,...
    'Label', 'Epoch &rejection',...
    'UserData', struct('CheckEnableFunction', @() isnonemptyfield(getactivedata, 'epoch'), 'msg', 'This option becomes available when epochs are defined'));

%% Rejection sub-menu

uimenu(trialRejectionMenu,...
    'Label', 'Reject by proportion &missing data (Lemercier et al., 2014)',...
    'Callback', @(src, event)...
        pupl_UI_procwrap(@pupl_epoch_reject, 'method', 'ppnmissing'));
uimenu(trialRejectionMenu,...
    'Label', 'Reject by ma&x pupil size',...
    'Callback', @(src, event)...
        pupl_UI_procwrap(@pupl_epoch_reject, 'method', 'max'));
uimenu(trialRejectionMenu,...
    'Label', 'Reject by mi&n pupil size',...
    'Callback', @(src, event)...
        pupl_UI_procwrap(@pupl_epoch_reject, 'method', 'min'));
uimenu(trialRejectionMenu,...
    'Label', 'Reject by &event attributes',...
    'Callback', @(src, event)...
        pupl_UI_procwrap(@pupl_epoch_reject, 'method', 'event'));
uimenu(trialRejectionMenu,...
    'Label', 'Reject by presense of &blinks',...
    'Callback', @(src, event)...
        pupl_UI_procwrap(@pupl_epoch_reject, 'method', 'blink'));
uimenu(trialRejectionMenu,...
    'Label', 'Reject by presense of &saccades',...
    'Callback', @(src, event)...
        pupl_UI_procwrap(@pupl_epoch_reject, 'method', 'sacc'));
uimenu(trialRejectionMenu,...
    'Label', 'Reject by &median absolute deviation',...
    'Callback', @(src, event)...
        pupl_UI_procwrap(@pupl_epoch_reject, 'method', 'mad'));
uimenu(trialRejectionMenu,...
    'Label', '&Un-reject all epochs',...
    'Separator', 'on',...
    'Callback', @(src, event)...
        pupl_UI_procwrap(@pupl_epoch_reject, 'method', 'undo'));

%% Rest of trials menu

uimenu(trialsMenu,...
    'Label', 'Define epoch &sets',...
    'UserData', struct('CheckEnableFunction', @() isnonemptyfield(getactivedata, 'epoch'), 'msg', 'This option becomes available when epochs are defined'),...
    'Callback', @(src, event)...
        pupl_UI_procwrap(@pupl_epochset));

%% Plotting menu
plottingMenu = uimenu(userInterface,...
    'Label', 'P&lot',...
    'UserData', struct('CheckEnableFunction', @() isnonemptyfield(getactivedata), 'msg', 'This option requires at least one recording to be currently active'));
scrollMenu = uimenu(plottingMenu,...
    'Label', 'Plot &continuous');
uimenu(scrollMenu,...
    'Label', 'P&upil size',...
    'Callback', @(src, event)...
        plotforeach(getactivedata, 'Continuous pupil size data', @pupl_plot_scroll, 'type', 'pupil'));
uimenu(scrollMenu,...
    'Label', 'Ga&ze',...
    'Callback', @(src, event)...
        plotforeach(getactivedata, 'Continuous gaze data', @pupl_plot_scroll, 'type', 'gaze'));
uimenu(plottingMenu,...
    'Label', '&Gaze scatterplot',...
    'Callback', @(src, event)...
        plotforeach(getactivedata, 'Gaze data', @pupl_plot_gazescatter));
uimenu(plottingMenu,...
    'Label', '&Pupil size histogram',...
    'Callback', @(src, event)...
        plotforeach(getactivedata, 'Pupil size', @pupl_plot_sizehist));
uimenu(plottingMenu,...
    'Label', '&Blink duration histogram',...
    'Callback', @(src, event)...
        plotforeach(getactivedata, 'Blink durations', @pupl_plot_blink_durs));
uimenu(plottingMenu,...
    'Label', '&Gap duration histogram',...
    'Callback', @(src, event)...
        plotforeach(getactivedata, 'Gap durations', @pupl_plot_gap_durs));
PFEplotmenu = uimenu(plottingMenu,...
    'Label', 'Pupil &foreshortening error');
uimenu(PFEplotmenu,...
    'Label', 'Error &surface (Hayes & Petrov, 2016)',...
    'Callback', @(h, e)...
        plotforeach(getactivedata, 'Pupil foreshortening error surface', @pupl_PFE_surface, 'error'));
uimenu(PFEplotmenu,...
    'Label', 'Pupil size vs gaze &y (Brisson et al., 2013)',...
    'Callback', @(src, event)...
        plotforeach(getactivedata, 'Pupil size vs. gaze y', @pupl_plot_PFE_lm, 'y'));
uimenu(PFEplotmenu,...
    'Label', 'Pupil size vs gaze &x (Brisson et al., 2013)',...
    'Callback', @(src, event)...
        plotforeach(getactivedata, 'Pupil size vs. gaze x', @pupl_plot_PFE_lm, 'x'));
uimenu(PFEplotmenu,...
    'Label', 'Pupil size vs piecewise quartic function of gaze &x (Gagl, Hawelka, & Hutzler, 2011)',...
    'Callback', @(src, event)...
        plotforeach(getactivedata, 'Pupil size vs piecewise quartic function of gaze x', @pupl_plot_PFE_quart));
uimenu(plottingMenu,...
    'Label', 'Plot &epochs',...
    'UserData', struct('CheckEnableFunction', @() isnonemptyfield(getactivedata, 'epoch'), 'msg', 'This option becomes available when epochs are defined'),...
    'Callback', @(src, event)...
        plotforeach(getactivedata, 'Epochs', @pupl_plot_epochs));
plotTrialSetsMenu = uimenu(plottingMenu,...
    'Label', 'Plot epoch &sets',...
    'UserData', struct('CheckEnableFunction', @() isnonemptyfield(getactivedata, 'epochset'), 'msg', 'This option becomes available when epoch sets are defined'));
linePlotMenu = uimenu(plotTrialSetsMenu,...
    'Label', '&Line plot with error bars');
uimenu(linePlotMenu,...
    'Label', '&Grand average',...
    'Callback', @(src, event)...
        pupl_plot_sets(getactivedata, 'grand', true));
uimenu(linePlotMenu,...
    'Label', '&Individual recordings',...
    'Callback', @(src, event)...
        pupl_plot_sets(getactivedata));
uimenu(plotTrialSetsMenu,...
    'Label', 'Data &matrix (similar to EEGLAB''s erpimage)',...
    'Callback', @(src, event)...
        pupl_plot_matrix(getactivedata));

%% Experiment menu

experimentmenu = uimenu(userInterface,...
    'Label', 'E&xperiment',...
    'UserData', struct('CheckEnableFunction', @() isnonemptyfield(getactivedata), 'msg', 'This option requires at least one recording to be currently active'));
uimenu(experimentmenu,...
    'Label', '&Assign recordings to conditions',...
    'Callback', @(src, event)...
        pupl_UI_procwrap(@pupl_condition));
uimenu(experimentmenu,...
    'Label', 'Export epoch &statistics',...
    'UserData', struct('CheckEnableFunction', @() isnonemptyfield(getactivedata, 'epochset'), 'msg', 'This option becomes available when epoch sets are defined'),...
    'Callback', @(src, event)...
        pupl_export(getactivedata,...
            'which', 'stats'));
uimenu(experimentmenu,...
    'Label', 'Export epoch &data',...
    'UserData', struct('CheckEnableFunction', @() isnonemptyfield(getactivedata, 'epochset'), 'msg', 'This option becomes available when epoch sets are defined'),...
    'Callback', @(src, event)...
        pupl_export(getactivedata,...
            'which', 'data'));
%% Help menu
helpMenu = uimenu(userInterface,...
    'Label', '&Help');
uimenu(helpMenu,...
    'Label', 'Open PuPl &manual',...
    'Callback', @(src, event)...
        web('github.com/kinleyid/PuPL/blob/master/manual.pdf', '-browser'));
uimenu(helpMenu,...
    'Label', 'What does "&regexp" mean?',...
    'Callback', @(src, event)...
        web('wikipedia.org/wiki/Regular_expression', '-browser'));
uimenu(helpMenu,...
    'Label', 'What are &Matlab''s regexp rules?',...
    'Callback', @(src, event)...
        web('mathworks.com/help/matlab/ref/regexp.html#btn_p45_sep_shared-expression', '-browser'));
uimenu(helpMenu,...
    'Label', 'What is &BIDS?',...
    'Callback', @(src, event)...
        web('bids.neuroimaging.io/', '-browser'));
uimenu(helpMenu,...
    'Label', 'How can I &convert my data to BIDS?',...
    'Callback', @(src, event)...
        web('pypi.org/project/dastr/', '-browser'));
uimenu(helpMenu,...
    'Label', 'What is &XDF?',...
    'Callback', @(src, event)...
        web('github.com/sccn/xdf/blob/master/README.md', '-browser'));
%% Citations
citeMenu = uimenu(userInterface,...
    'Label', '&Citations');
uimenu(citeMenu,...
    'Label', 'Brisson et al., 2013',...
    'Callback', @(src, event)...
        web('doi.org/10.3758/s13428-013-0327-0', '-browser'));
uimenu(citeMenu,...
    'Label', 'Gagl, Hawelka, & Hutzler, 2011',...
    'Callback', @(src, event)...
        web('doi.org/10.3758/s13428-011-0109-5', '-browser'));
uimenu(citeMenu,...
    'Label', 'Hayes & Petrov, 2016',...
    'Callback', @(src, event)...
        web('doi.org/10.3758/s13428-015-0588-x', '-browser'));
uimenu(citeMenu,...
    'Label', 'Hershman, Henik, & Cohen, 2018',...
    'Callback', @(src, event)...
        web('https://doi.org/10.3758/s13428-017-1008-1', '-browser'));
uimenu(citeMenu,...
    'Label', 'Kret & Sjak-Shie, 2019',...
    'Callback', @(src, event)...
        web('doi.org/10.3758/s13428-018-1075-y', '-browser'));
uimenu(citeMenu,...
    'Label', 'Lemercier et al., 2014',...
    'Callback', @(src, event)...
        web('hal.archives-ouvertes.fr/hal-01249252/', '-browser'));
uimenu(citeMenu,...
    'Label', ['Math' char(244) 't, 2013'],...
    'Callback', @(src, event)...
        web('researchgate.net/publication/236268543_A_simple_way_to_reconstruct_pupil_size_during_eye_blinks', '-browser'));
uimenu(citeMenu,...
    'Label', 'Salvucci & Goldberg, 2000',...
    'Callback', @(src, event)...
        web('doi.org/10.1145/355017.355028', '-browser'));
uimenu(citeMenu,...
    'Label', 'Winn, Wendt, Koelewijn, & Kuchinsky, 2018',...
    'Callback', @(src, event)...
        web('doi.org/10.1177/2331216518800869', '-browser'));
uimenu(citeMenu,...
    'Tag', 'pupl:hidden-menu',...
    'Visible', 'off');

update_UI;

pupl_UI_addimporter(...
    'loadfunc', @pupl_txt,...
    'label', 'From PuPl text (.txt)',...
    'args', {'r', 'ce'},...
    'filefilt', '*.txt')
pupl_UI_addimporter(...
    'type', 'event',...
    'loadfunc', @pupl_txt,...
    'label', 'From PuPl text (.csv)',...
    'args', {'r', 'e'},...
    'filefilt', '*.csv')
pupl_UI_addimporter(...
    'type', 'event',...
    'loadfunc', @pupl_mat,...
    'label', 'From .mat',...
    'args', {'r', 'e'},...
    'filefilt', '*.mat')
pupl_UI_addimporter(...
    'loadfunc', @tsv2eventlog,...
    'type', 'event',....
    'filefilt', '*.tsv',...
    'label', 'From &BIDS-compliant TSV');

end

function scrolldatapanel(ignored, eventdata)

scroller = findobj('Tag', 'dataScroller');

if isempty(eventdata) % Octave
    eventdata = struct('EventName', 'action');
end
switch lower(eventdata.EventName)
    case 'windowscrollwheel'
        scroll_start = get(scroller, 'Value');
        scroll_amt = eventdata.VerticalScrollCount * eventdata.VerticalScrollAmount / 100;
        scroll_pos = scroll_start - scroll_amt;
        if scroll_pos < 0
            scroll_pos = 0;
        elseif scroll_pos > 1
            scroll_pos = 1;
        end
        set(scroller, 'Value', scroll_pos);
    case 'action'
        scroll_pos = get(scroller, 'Value');
end

datapanel = findobj('Tag', 'activeEyeDataPanel');
datapanel_pos = get(datapanel, 'Position');
max_scroll = datapanel_pos(4) - 1;
if max_scroll == 0
    set(scroller, 'Value', 1);
else
    datapanel_pos(2) = - max_scroll * scroll_pos;
end
set(datapanel, 'Position', datapanel_pos);

end

function out = timeline_allowed(direction)

global pupl_globals

idx = find(strcmp(pupl_globals.timeline.data, 'curr'));
out = false;
if ismember(direction, {'forward' 'f' 'any'})
    if idx < numel(pupl_globals.timeline.data)
        out = true;
    end
end
if ismember(direction, {'backward' 'b' 'any'})
    if idx > 1
        out = true;
    end
end
if ismember(direction, {'flush'})
    out = numel(pupl_globals.timeline.data) > 1;
end

end
